# –ü–æ–ª–Ω—ã–π –∫—É—Ä—Å Rust: –û—Ç –æ—Å–Ω–æ–≤ –¥–æ Backend —Å Axum
**–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ã–π –∫—É—Ä—Å –≤ —Å—Ç–∏–ª–µ JavaRush**
**~300+ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á | 16 –Ω–µ–¥–µ–ª—å**
+
---

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–ú–æ–¥—É–ª—å 1: –û—Å–Ω–æ–≤—ã —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ](#–º–æ–¥—É–ª—å-1-–æ—Å–Ω–æ–≤—ã-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞-–∏-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ)
2. [–ú–æ–¥—É–ª—å 2: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º](#–º–æ–¥—É–ª—å-2-—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–º)
3. [–ú–æ–¥—É–ª—å 3: –¶–∏–∫–ª—ã](#–º–æ–¥—É–ª—å-3-—Ü–∏–∫–ª—ã)
4. [–ú–æ–¥—É–ª—å 4: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫](#–º–æ–¥—É–ª—å-4-–æ–±—Ä–∞–±–æ—Ç–∫–∞-–æ—à–∏–±–æ–∫-–∏-–ø–∞–Ω–∏–∫–∏)
5. [–ú–æ–¥—É–ª—å 5: Ownership –∏ Borrowing](#–º–æ–¥—É–ª—å-5-ownership-–∏-borrowing)
6. [–ú–æ–¥—É–ª—å 6: –°—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –º–µ—Ç–æ–¥—ã](#–º–æ–¥—É–ª—å-6-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–∏-–º–µ—Ç–æ–¥—ã)
7. [–ú–æ–¥—É–ª—å 7: Enums –∏ Pattern Matching](#–º–æ–¥—É–ª—å-7-enums-–∏-pattern-matching)
8. [–ú–æ–¥—É–ª—å 8: –ö–æ–ª–ª–µ–∫—Ü–∏–∏](#–º–æ–¥—É–ª—å-8-–∫–æ–ª–ª–µ–∫—Ü–∏–∏)
9. [–ú–æ–¥—É–ª—å 9: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ (Result)](#–º–æ–¥—É–ª—å-9-–æ–±—Ä–∞–±–æ—Ç–∫–∞-–æ—à–∏–±–æ–∫-result)
10. [–ú–æ–¥—É–ª—å 10: Generics –∏ Traits](#–º–æ–¥—É–ª—å-10-generics-–∏-traits)
11. [–ú–æ–¥—É–ª—å 11: Iterators –∏ Closures](#–º–æ–¥—É–ª—å-11-iterators-–∏-closures)
12. [–ú–æ–¥—É–ª—å 12: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#–º–æ–¥—É–ª—å-12-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
13. [–ú–æ–¥—É–ª—å 13: Smart Pointers](#–º–æ–¥—É–ª—å-13-smart-pointers)
14. [–ú–æ–¥—É–ª—å 14: Concurrency](#–º–æ–¥—É–ª—å-14-concurrency)
15. [–ú–æ–¥—É–ª—å 15: Async/Await](#–º–æ–¥—É–ª—å-15-asyncawait)
16. [–ú–æ–¥—É–ª—å 16: Backend —Å Axum](#–º–æ–¥—É–ª—å-16-backend-—Å-axum)

---

# –ú–û–î–£–õ–¨ 1: –û—Å–Ω–æ–≤—ã —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
**–ù–µ–¥–µ–ª–∏: 1-2 | –ó–∞–¥–∞—á–∏: 20 | Rust Book: –ì–ª–∞–≤—ã 1-3**

## –¢–µ–æ—Ä–∏—è

### 1.1 –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –ø–µ—Ä–≤–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞

**–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏:**
- Rust - —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —è–∑—ã–∫ —Å —É–ø–æ—Ä–æ–º –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–∞–º—è—Ç–∏ –±–µ–∑ GC
- Cargo - –º–µ–Ω–µ–¥–∂–µ—Ä –ø–∞–∫–µ—Ç–æ–≤ –∏ —Å–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏ (–∞–Ω–∞–ª–æ–≥ Maven –≤ Java)
- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∫–∞–∫ "–ø—Ä–∏–≤—Ä–∞—Ç–Ω–∏–∫" - –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç –∫–æ–¥ —Å –æ—à–∏–±–∫–∞–º–∏

**–ö–æ–º–∞–Ω–¥—ã:**
```bash
# –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
cargo new my_project
cd my_project

# –ó–∞–ø—É—Å–∫ (–∫–æ–º–ø–∏–ª—è—Ü–∏—è + –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ)
cargo run

# –¢–æ–ª—å–∫–æ –∫–æ–º–ø–∏–ª—è—Ü–∏—è
cargo build

# –ö–æ–º–ø–∏–ª—è—Ü–∏—è —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
cargo build --release

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑ —Å–±–æ—Ä–∫–∏ (–±—ã—Å—Ç—Ä–æ!)
cargo check

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
cargo test

# –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
cargo fmt

# –õ–∏–Ω—Ç–µ—Ä
cargo clippy
```

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:**
```
my_project/
‚îú‚îÄ‚îÄ Cargo.toml       # –ú–∞–Ω–∏—Ñ–µ—Å—Ç (–∫–∞–∫ pom.xml)
‚îú‚îÄ‚îÄ Cargo.lock       # –ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs      # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
‚îÇ   ‚îî‚îÄ‚îÄ lib.rs       # –ë–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫–æ–¥
‚îî‚îÄ‚îÄ target/          # –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
```

**Hello World:**
```rust
fn main() {
    println!("Hello, world!");
}
```

---

### 1.2 –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ —Ç–∏–ø—ã

**–ö–ª—é—á–µ–≤—ã–µ –æ—Ç–ª–∏—á–∏—è –æ—Ç Java:**
| Java | Rust |
|------|------|
| –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –º—É—Ç–∞–±–µ–ª—å–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é | –ò–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é |
| `null` –¥–ª—è –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∑–Ω–∞—á–µ–Ω–∏—è | `Option<T>` |
| –ò—Å–∫–ª—é—á–µ–Ω–∏—è –¥–ª—è –æ—à–∏–±–æ–∫ | `Result<T, E>` |
| GC —É–ø—Ä–∞–≤–ª—è–µ—Ç –ø–∞–º—è—Ç—å—é | –°–∏—Å—Ç–µ–º–∞ –≤–ª–∞–¥–µ–Ω–∏—è (ownership) |
| –ü—Ä–∏–º–∏—Ç–∏–≤—ã –∏ —Å—Å—ã–ª–∫–∏ | –í—Å–µ —Ç–∏–ø—ã –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω—ã |

**–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã:**
| –†–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å | –ó–Ω–∞–∫–æ–≤—ã–π | –ë–µ–∑–∑–Ω–∞–∫–æ–≤—ã–π | –î–∏–∞–ø–∞–∑–æ–Ω (–∑–Ω–∞–∫–æ–≤—ã–π) |
|-------------|----------|-------------|---------------------|
| 8 –±–∏—Ç | `i8` | `u8` | -128 –¥–æ 127 |
| 16 –±–∏—Ç | `i16` | `u16` | -32,768 –¥–æ 32,767 |
| 32 –±–∏—Ç | `i32` (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) | `u32` | -2¬≥¬π –¥–æ 2¬≥¬π-1 |
| 64 –±–∏—Ç | `i64` | `u64` | -2‚Å∂¬≥ –¥–æ 2‚Å∂¬≥-1 |
| 128 –±–∏—Ç | `i128` | `u128` | –æ–≥—Ä–æ–º–Ω—ã–µ —á–∏—Å–ª–∞ |
| –†–∞–∑–º–µ—Ä —É–∫–∞–∑–∞—Ç–µ–ª—è | `isize` | `usize` | –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã |

**–í–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã:**
- `f32` - –æ–¥–∏–Ω–∞—Ä–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å
- `f64` - –¥–≤–æ–π–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)

**–î—Ä—É–≥–∏–µ —Ç–∏–ø—ã:**
- `bool` - true/false
- `char` - Unicode —Å–∏–º–≤–æ–ª (4 –±–∞–π—Ç–∞!)

**–°–∏–Ω—Ç–∞–∫—Å–∏—Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:**
```rust
// –ò–º–º—É—Ç–∞–±–µ–ª—å–Ω–∞—è (–Ω–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å)
let x = 5;
let y: u64 = 100;       // —è–≤–Ω—ã–π —Ç–∏–ø

// –ú—É—Ç–∞–±–µ–ª—å–Ω–∞—è (–º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å)
let mut z = 10;
z = 15;                  // OK

// Shadowing (–∑–∞—Ç–µ–Ω–µ–Ω–∏–µ) - —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
let x = 5;
let x = x + 1;           // –Ω–æ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è x = 6
let x = "—Å—Ç—Ä–æ–∫–∞";        // –¥–∞–∂–µ —Ç–∏–ø –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è!

// –ß–∏—Å–ª–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã
let million = 1_000_000;     // –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
let hex = 0xff;              // —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π
let binary = 0b1111_0000;    // –¥–≤–æ–∏—á–Ω—ã–π
let byte = b'A';             // –±–∞–π—Ç (—Ç–æ–ª—å–∫–æ u8)
let suffix = 42u64;          // —Å—É—Ñ—Ñ–∏–∫—Å —Ç–∏–ø–∞
```

**–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã:**
```rust
// –í—Å–µ–≥–¥–∞ –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã, —Ç–∏–ø –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159;
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 1.1: Hello, Rust!
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 5 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –§—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ò–∑–º–µ–Ω–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–ª–∞ —Å—Ç—Ä–æ–∫—É "I'm ready to learn Rust!"

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs
fn greeting() -> &'static str {
    // TODO: –∏—Å–ø—Ä–∞–≤—å—Ç–µ —Å—Ç—Ä–æ–∫—É
    "I'm ready to ___!"
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_greeting() {
        assert_eq!(greeting(), "I'm ready to learn Rust!");
    }
}
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**
- `&'static str` - —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å—Ç—Ä–æ–∫—É, —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –≤—Å—ë –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã
- –ü–æ—Å–ª–µ–¥–Ω–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –±–µ–∑ `;` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏
- –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `return`, –Ω–æ —ç—Ç–æ –Ω–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω–æ

**–ö—Ä–∏—Ç–µ—Ä–∏–∏:**
- ‚úÖ –¢–µ—Å—Ç –ø—Ä–æ—Ö–æ–¥–∏—Ç
- ‚úÖ –ù–µ—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞

---

### –ó–∞–¥–∞—á–∞ 1.2: –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 10 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –§—É–Ω–∫—Ü–∏–∏, –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏: speed = distance / time

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs

/// –í—ã—á–∏—Å–ª—è–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞
///
/// # Arguments
/// * `start` - –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–º–µ—Ç—Ä—ã)
/// * `end` - –∫–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–º–µ—Ç—Ä—ã)
/// * `time_elapsed` - –∑–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è (—Å–µ–∫—É–Ω–¥—ã)
///
/// # Returns
/// –°–∫–æ—Ä–æ—Å—Ç—å –≤ –º–µ—Ç—Ä–∞—Ö/—Å–µ–∫—É–Ω–¥—É
fn speed(start: u32, end: u32, time_elapsed: u32) -> u32 {
    // TODO:
    // 1. –í—ã—á–∏—Å–ª–∏—Ç–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏—é (end - start)
    // 2. –†–∞–∑–¥–µ–ª–∏—Ç–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏—é –Ω–∞ –≤—Ä–µ–º—è
    todo!() // –º–∞–∫—Ä–æ—Å todo!() –≤—ã–∑—ã–≤–∞–µ—Ç –ø–∞–Ω–∏–∫—É
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_speed_basic() {
        assert_eq!(speed(0, 10, 2), 5);
    }

    #[test]
    fn test_speed_with_start() {
        assert_eq!(speed(10, 30, 4), 5);
    }

    #[test]
    fn test_speed_large() {
        assert_eq!(speed(0, 100, 10), 10);
    }
}
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**
- –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ—Ç –¥—Ä–æ–±–Ω—É—é —á–∞—Å—Ç—å: `5 / 2 == 2`
- –û–ø–µ—Ä–∞—Ç–æ—Ä—ã: `+`, `-`, `*`, `/`, `%`
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∫–æ–±–∫–∏ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –ø–æ—Ä—è–¥–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–π

---

### –ó–∞–¥–∞—á–∞ 1.3: –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é –¶–µ–ª—å—Å–∏–π ‚Üî –§–∞—Ä–µ–Ω–≥–µ–π—Ç

–§–æ—Ä–º—É–ª—ã:
- F = C √ó 9 / 5 + 32
- C = (F - 32) √ó 5 / 9

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs

fn celsius_to_fahrenheit(celsius: i32) -> i32 {
    // TODO: F = C * 9 / 5 + 32
    // –í–ê–ñ–ù–û: –ø–æ—Ä—è–¥–æ–∫ –æ–ø–µ—Ä–∞—Ü–∏–π!
    todo!()
}

fn fahrenheit_to_celsius(fahrenheit: i32) -> i32 {
    // TODO: C = (F - 32) * 5 / 9
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_celsius_to_fahrenheit() {
        assert_eq!(celsius_to_fahrenheit(0), 32);
        assert_eq!(celsius_to_fahrenheit(100), 212);
        assert_eq!(celsius_to_fahrenheit(-40), -40);
        assert_eq!(celsius_to_fahrenheit(25), 77);
    }

    #[test]
    fn test_fahrenheit_to_celsius() {
        assert_eq!(fahrenheit_to_celsius(32), 0);
        assert_eq!(fahrenheit_to_celsius(212), 100);
        assert_eq!(fahrenheit_to_celsius(-40), -40);
    }
}
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `i32` –¥–ª—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä
- –°–∫–æ–±–∫–∏ –≤–∞–∂–Ω—ã: `(a + b) * c`
- –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Ç–æ—á–Ω—ã–º

---

### –ó–∞–¥–∞—á–∞ 1.4: –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 10 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤, –Ω–µ—Ç –∞–≤—Ç–æ–∫–∞—Å—Ç–∏–Ω–≥–∞

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ò—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∏—Å–ø–æ–ª—å–∑—É—è —è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥ (–ù–ï –ö–û–ú–ü–ò–õ–ò–†–£–ï–¢–°–Ø!):**
```rust
// src/lib.rs

fn mix_types() -> u32 {
    let a: u8 = 100;
    let b: u16 = 200;
    let c: u32 = 300;

    // TODO: –∏—Å–ø—Ä–∞–≤—å—Ç–µ - –Ω–µ–ª—å–∑—è —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã!
    let result = a + b + c;

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mix_types() {
        assert_eq!(mix_types(), 600);
    }
}
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `as` –¥–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è: `a as u32`
- Rust –ù–ï –¥–µ–ª–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è
- –ü—Ä–∏–≤–æ–¥–∏—Ç–µ –º–µ–Ω—å—à–∏–µ —Ç–∏–ø—ã –∫ –±–æ–ª—å—à–∏–º

**–†–µ—à–µ–Ω–∏–µ (–Ω–µ –ø–æ–¥–≥–ª—è–¥—ã–≤–∞–π—Ç–µ!):**
```rust
fn mix_types() -> u32 {
    let a: u8 = 100;
    let b: u16 = 200;
    let c: u32 = 300;
    let result = (a as u32) + (b as u32) + c;
    result
}
```

---

### –ó–∞–¥–∞—á–∞ 1.5: –ú—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 10 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** mut, –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ò—Å–ø—Ä–∞–≤—å—Ç–µ –∫–æ–¥, –¥–æ–±–∞–≤–∏–≤ `mut` –≥–¥–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥ (–ù–ï –ö–û–ú–ü–ò–õ–ò–†–£–ï–¢–°–Ø!):**
```rust
// src/lib.rs

fn accumulate_sum(limit: u32) -> u32 {
    // TODO: –¥–æ–±–∞–≤—å—Ç–µ mut –≥–¥–µ –Ω—É–∂–Ω–æ
    let sum = 0;
    let i = 1;

    while i <= limit {
        sum = sum + i;
        i = i + 1;
    }

    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_accumulate() {
        assert_eq!(accumulate_sum(5), 15); // 1+2+3+4+5
        assert_eq!(accumulate_sum(10), 55);
        assert_eq!(accumulate_sum(0), 0);
    }
}
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**
- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
- `let mut x = 5;` –¥–ª—è –º—É—Ç–∞–±–µ–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
- –ü–æ–¥—É–º–∞–π—Ç–µ, –∫–∞–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω—è—é—Ç—Å—è

---

### –ó–∞–¥–∞—á–∞ 1.6: Shadowing vs Mutation
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É shadowing –∏ mut

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –¥–≤–µ –≤–µ—Ä—Å–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è: —á–µ—Ä–µ–∑ shadowing –∏ —á–µ—Ä–µ–∑ mut

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs

// –í–µ—Ä—Å–∏—è —Å shadowing
fn transform_shadowing(value: i32) -> i32 {
    // TODO: –∏—Å–ø–æ–ª—å–∑—É—è shadowing (let x = ...; let x = ...;)
    // 1. –£–¥–≤–æ–π—Ç–µ value
    // 2. –ü—Ä–∏–±–∞–≤—å—Ç–µ 10
    // 3. –£–º–Ω–æ–∂—å—Ç–µ –Ω–∞ 3
    todo!()
}

// –í–µ—Ä—Å–∏—è —Å –º—É—Ç–∞—Ü–∏–µ–π
fn transform_mutation(value: i32) -> i32 {
    // TODO: –∏—Å–ø–æ–ª—å–∑—É—è let mut
    // –¢–µ –∂–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transform_shadowing() {
        assert_eq!(transform_shadowing(5), 60); // (5*2+10)*3
        assert_eq!(transform_shadowing(0), 30); // (0*2+10)*3
    }

    #[test]
    fn test_transform_mutation() {
        assert_eq!(transform_mutation(5), 60);
        assert_eq!(transform_mutation(0), 30);
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn transform_shadowing(value: i32) -> i32 {
    let value = value * 2;
    let value = value + 10;
    let value = value * 3;
    value
}

fn transform_mutation(value: i32) -> i32 {
    let mut result = value * 2;
    result = result + 10;
    result = result * 3;
    result
}
```

---

### –ó–∞–¥–∞—á–∏ 1.7-1.20: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è

**1.7: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ç–Ω–æ—Å—Ç–∏** üåü
```rust
fn is_even(n: i32) -> bool {
    // TODO: –≤–µ—Ä–Ω–∏—Ç–µ true –µ—Å–ª–∏ n —á–µ—Ç–Ω–æ–µ
    todo!()
}
```

**1.8: –ê–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ** üåü
```rust
fn abs(n: i32) -> i32 {
    // TODO: –≤–µ—Ä–Ω–∏—Ç–µ |n|
    // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ if
    todo!()
}
```

**1.9: –ú–∞–∫—Å–∏–º—É–º –∏–∑ –¥–≤—É—Ö** üåü
```rust
fn max(a: i32, b: i32) -> i32 {
    // TODO: –≤–µ—Ä–Ω–∏—Ç–µ –Ω–∞–∏–±–æ–ª—å—à–µ–µ
    todo!()
}
```

**1.10: –ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞** üåü
```rust
fn rectangle_area(width: u32, height: u32) -> u32 {
    todo!()
}
```

[–ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å–æ –≤—Å–µ–º–∏ –∑–∞–¥–∞—á–∞–º–∏...]

---

# –ú–û–î–£–õ–¨ 2: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º
**–ù–µ–¥–µ–ª–∏: 2 | –ó–∞–¥–∞—á–∏: 15 | Rust Book: –ì–ª–∞–≤–∞ 3**

## –¢–µ–æ—Ä–∏—è

### 2.1 –£—Å–ª–æ–≤–∏—è if/else

**–°–∏–Ω—Ç–∞–∫—Å–∏—Å:**
```rust
let number = 7;

if number < 5 {
    println!("–º–µ–Ω—å—à–µ 5");
} else if number < 10 {
    println!("–æ—Ç 5 –¥–æ 9");
} else {
    println!("10 –∏–ª–∏ –±–æ–ª—å—à–µ");
}
```

**–í–ê–ñ–ù–û:** –£—Å–ª–æ–≤–∏–µ –û–ë–Ø–ó–ê–ù–û –±—ã—Ç—å `bool`!
```rust
// ‚ùå –ù–ï –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è
let x = 5;
if x {  // error: –Ω–µ—Ç truthy/falsy
    println!("x –Ω–µ –Ω–æ–ª—å");
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ
if x != 0 {
    println!("x –Ω–µ –Ω–æ–ª—å");
}
```

**if –∫–∞–∫ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ:**
```rust
let condition = true;
let number = if condition { 5 } else { 6 };
// number == 5

// –û–±–µ –≤–µ—Ç–∫–∏ –¥–æ–ª–∂–Ω—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –û–î–ò–ù–ê–ö–û–í–´–ô —Ç–∏–ø!
// ‚ùå –ù–ï –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:
let bad = if true { 5 } else { "—à–µ—Å—Ç—å" };
```

**–û–ø–µ—Ä–∞—Ç–æ—Ä—ã —Å—Ä–∞–≤–Ω–µ–Ω–∏—è:**
- `==` —Ä–∞–≤–Ω–æ
- `!=` –Ω–µ —Ä–∞–≤–Ω–æ
- `<` –º–µ–Ω—å—à–µ
- `>` –±–æ–ª—å—à–µ
- `<=` –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ
- `>=` –±–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ

**–õ–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã:**
- `&&` –ò (AND)
- `||` –ò–õ–ò (OR)
- `!` –ù–ï (NOT)

```rust
let age = 25;
let has_license = true;

// –ú–æ–∂–Ω–æ –ª–∏ –≤–æ–¥–∏—Ç—å?
if age >= 18 && has_license {
    println!("–ú–æ–∂–µ—Ç–µ –≤–æ–¥–∏—Ç—å");
}

// –°–æ–∫—Ä–∞—â–µ–Ω–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ (short-circuit)
if false && expensive_function() {
    // expensive_function() –ù–ï –≤—ã–∑–æ–≤–µ—Ç—Å—è
}
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 2.1: FizzBuzz
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –í–ª–æ–∂–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è, –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –æ—Å—Ç–∞—Ç–∫–æ–º

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ FizzBuzz:
- –î–µ–ª–∏—Ç—Å—è –Ω–∞ 3 ‚Üí "Fizz"
- –î–µ–ª–∏—Ç—Å—è –Ω–∞ 5 ‚Üí "Buzz"
- –î–µ–ª–∏—Ç—Å—è –Ω–∞ 3 –ò 5 ‚Üí "FizzBuzz"
- –ò–Ω–∞—á–µ ‚Üí —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —á–∏—Å–ª–∞

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs

fn fizzbuzz(n: u32) -> String {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ FizzBuzz
    // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 15 –ü–ï–†–ï–î 3 –∏ 5!
    // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ n % 3 == 0
    // –ü–æ–¥—Å–∫–∞–∑–∫–∞: n.to_string() –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —á–∏—Å–ª–æ –≤ String
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fizz() {
        assert_eq!(fizzbuzz(3), "Fizz");
        assert_eq!(fizzbuzz(6), "Fizz");
        assert_eq!(fizzbuzz(9), "Fizz");
    }

    #[test]
    fn test_buzz() {
        assert_eq!(fizzbuzz(5), "Buzz");
        assert_eq!(fizzbuzz(10), "Buzz");
    }

    #[test]
    fn test_fizzbuzz() {
        assert_eq!(fizzbuzz(15), "FizzBuzz");
        assert_eq!(fizzbuzz(30), "FizzBuzz");
        assert_eq!(fizzbuzz(45), "FizzBuzz");
    }

    #[test]
    fn test_number() {
        assert_eq!(fizzbuzz(1), "1");
        assert_eq!(fizzbuzz(2), "2");
        assert_eq!(fizzbuzz(7), "7");
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn fizzbuzz(n: u32) -> String {
    if n % 15 == 0 {
        String::from("FizzBuzz")
    } else if n % 3 == 0 {
        String::from("Fizz")
    } else if n % 5 == 0 {
        String::from("Buzz")
    } else {
        n.to_string()
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 2.2: –í–∏—Å–æ–∫–æ—Å–Ω—ã–π –≥–æ–¥
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç
**–¢–µ–æ—Ä–∏—è:** –°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞, –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã

**–ü—Ä–∞–≤–∏–ª–∞:**
1. –î–µ–ª–∏—Ç—Å—è –Ω–∞ 4 –ë–ï–ó –æ—Å—Ç–∞—Ç–∫–∞ ‚Üí –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π
2. –ù–û –µ—Å–ª–∏ –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 100 ‚Üí –ù–ï –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π
3. –ù–û –µ—Å–ª–∏ –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 400 ‚Üí –í–°–Å –ñ–ï –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π

**–ü—Ä–∏–º–µ—Ä—ã:**
- 2000 ‚Üí true (–¥–µ–ª–∏—Ç—Å—è –Ω–∞ 400)
- 1900 ‚Üí false (–¥–µ–ª–∏—Ç—Å—è –Ω–∞ 100, –Ω–æ –Ω–µ –Ω–∞ 400)
- 2004 ‚Üí true (–¥–µ–ª–∏—Ç—Å—è –Ω–∞ 4, –Ω–æ –Ω–µ –Ω–∞ 100)

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// src/lib.rs

fn is_leap_year(year: u32) -> bool {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É
    // –ú–æ–∂–Ω–æ –æ–¥–Ω–∏–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º –∏–ª–∏ —á–µ—Ä–µ–∑ if/else
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divisible_by_400() {
        assert!(is_leap_year(2000));
        assert!(is_leap_year(2400));
    }

    #[test]
    fn test_divisible_by_100_not_400() {
        assert!(!is_leap_year(1900));
        assert!(!is_leap_year(2100));
    }

    #[test]
    fn test_divisible_by_4_not_100() {
        assert!(is_leap_year(2004));
        assert!(is_leap_year(2024));
    }

    #[test]
    fn test_not_divisible_by_4() {
        assert!(!is_leap_year(2001));
        assert!(!is_leap_year(2019));
    }
}
```

**–ö–æ–º–ø–∞–∫—Ç–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:**
```rust
fn is_leap_year(year: u32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}
```

---

[–ó–∞–¥–∞—á–∏ 2.3-2.15 –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç—Å—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ...]

---

# –ú–û–î–£–õ–¨ 3: –¶–∏–∫–ª—ã
**–ù–µ–¥–µ–ª–∏: 2-3 | –ó–∞–¥–∞—á–∏: 18 | Rust Book: –ì–ª–∞–≤–∞ 3**

## –¢–µ–æ—Ä–∏—è

### 3.1 –¶–∏–∫–ª loop (–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π)

```rust
let mut count = 0;
loop {
    count += 1;
    if count == 10 {
        break; // –≤—ã—Ö–æ–¥
    }
}

// –í–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ loop
let result = loop {
    count += 1;
    if count == 20 {
        break count * 2; // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
    }
};
```

### 3.2 –¶–∏–∫–ª while

```rust
let mut number = 3;

while number != 0 {
    println!("{}!", number);
    number -= 1;
}
```

### 3.3 –¶–∏–∫–ª for

```rust
// –î–∏–∞–ø–∞–∑–æ–Ω—ã (ranges)
for i in 1..5 {      // 1, 2, 3, 4 (–Ω–µ –≤–∫–ª—é—á–∞–µ—Ç 5)
    println!("{}", i);
}

for i in 1..=5 {     // 1, 2, 3, 4, 5 (–≤–∫–ª—é—á–∞–µ—Ç 5)
    println!("{}", i);
}

// –û–±—Ä–∞—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
for i in (1..5).rev() {  // 4, 3, 2, 1
    println!("{}", i);
}

// –° —à–∞–≥–æ–º
for i in (0..10).step_by(2) {  // 0, 2, 4, 6, 8
    println!("{}", i);
}
```

### 3.4 –ú–µ—Ç–∫–∏ —Ü–∏–∫–ª–æ–≤

```rust
'outer: for x in 0..5 {
    for y in 0..5 {
        if x == 2 && y == 2 {
            break 'outer; // –≤—ã—Ö–æ–¥ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ —Ü–∏–∫–ª–∞
        }
    }
}
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 3.1: –§–∞–∫—Ç–æ—Ä–∏–∞–ª (while)
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn factorial_while(n: u32) -> u32 {
    // TODO: –≤—ã—á–∏—Å–ª–∏—Ç–µ n! –∏—Å–ø–æ–ª—å–∑—É—è while
    // 0! = 1, 5! = 1*2*3*4*5 = 120
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_factorial() {
        assert_eq!(factorial_while(0), 1);
        assert_eq!(factorial_while(1), 1);
        assert_eq!(factorial_while(5), 120);
        assert_eq!(factorial_while(10), 3_628_800);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 3.2: –§–∞–∫—Ç–æ—Ä–∏–∞–ª (for)
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 10 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn factorial_for(n: u32) -> u32 {
    let mut result = 1;
    // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ for —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º 1..=n
    todo!()
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn factorial_for(n: u32) -> u32 {
    let mut result = 1;
    for i in 1..=n {
        result *= i;
    }
    result
}
```

---

### –ó–∞–¥–∞—á–∞ 3.3: –°—É–º–º–∞ —á—ë—Ç–Ω—ã—Ö
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn sum_of_evens(n: u32) -> u32 {
    // TODO: –ø—Ä–æ—Å—É–º–º–∏—Ä—É–π—Ç–µ –≤—Å–µ —á—ë—Ç–Ω—ã–µ –æ—Ç 1 –¥–æ n
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum() {
        assert_eq!(sum_of_evens(10), 30); // 2+4+6+8+10
        assert_eq!(sum_of_evens(5), 6);   // 2+4
        assert_eq!(sum_of_evens(1), 0);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 3.4: –§–∏–±–æ–Ω–∞—á—á–∏
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–í—Ä–µ–º—è:** 25 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn fibonacci(n: u32) -> u64 {
    if n == 0 { return 0; }
    if n == 1 { return 1; }

    // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–∏–∫–ª —Å –¥–≤—É–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏
    // prev, curr
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib() {
        assert_eq!(fibonacci(0), 0);
        assert_eq!(fibonacci(1), 1);
        assert_eq!(fibonacci(2), 1);
        assert_eq!(fibonacci(10), 55);
        assert_eq!(fibonacci(20), 6765);
    }
}
```

---

[–ó–∞–¥–∞—á–∏ 3.5-3.18: –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å —Ü–∏–∫–ª–∞–º–∏...]

---

# –ú–û–î–£–õ–¨ 4: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –ø–∞–Ω–∏–∫–∏
**–ù–µ–¥–µ–ª–∏: 3 | –ó–∞–¥–∞—á–∏: 12 | Rust Book: –ì–ª–∞–≤–∞ 9**

## –¢–µ–æ—Ä–∏—è

### 4.1 Panic! - –Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ –æ—à–∏–±–∫–∏

```rust
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("–î–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å!");
    }
    a / b
}
```

### 4.2 –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ (Overflow)

–í debug: –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ ‚Üí –ø–∞–Ω–∏–∫–∞
–í release: –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ ‚Üí wrapping (–æ–±–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ)

```rust
let x: u8 = 255;
// –í debug: –ø–∞–Ω–∏–∫–∞
// –í release: x + 1 == 0
```

**–ú–µ—Ç–æ–¥—ã –∫–æ–Ω—Ç—Ä–æ–ª—è:**
```rust
let x: u8 = 255;

// Wrapping - —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–µ
assert_eq!(x.wrapping_add(1), 0);

// Saturating - –Ω–∞—Å—ã—â–µ–Ω–∏–µ
assert_eq!(x.saturating_add(1), 255);

// Checked - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Option
assert_eq!(x.checked_add(1), None);
assert_eq!(x.checked_add(0), Some(255));

// Overflowing - (—Ä–µ–∑—É–ª—å—Ç–∞—Ç, —Ñ–ª–∞–≥)
let (result, overflow) = x.overflowing_add(1);
assert_eq!(result, 0);
assert!(overflow);
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 4.1: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn safe_divide(dividend: i32, divisor: i32) -> i32 {
    // TODO: –ø—Ä–æ–≤–µ—Ä—å—Ç–µ divisor != 0, –∏–Ω–∞—á–µ panic!
    todo!()
}

#[cfg(test)]
mod tests {
    #[test]
    #[should_panic(expected = "–Ω–æ–ª—å")]
    fn test_panic() {
        safe_divide(10, 0);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 4.2: –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn checked_factorial(n: u32) -> Option<u32> {
    let mut result = 1u32;
    for i in 2..=n {
        // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ checked_mul
        result = todo!();
    }
    Some(result)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_overflow() {
        assert_eq!(checked_factorial(13), None); // –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
        assert_eq!(checked_factorial(12), Some(479_001_600));
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn checked_factorial(n: u32) -> Option<u32> {
    let mut result = 1u32;
    for i in 2..=n {
        result = result.checked_mul(i)?; // ? –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None
    }
    Some(result)
}
```

---

[–ó–∞–¥–∞—á–∏ 4.3-4.12...]

---

# –ú–û–î–£–õ–¨ 5: Ownership –∏ Borrowing
**–ù–µ–¥–µ–ª–∏: 4-5 | –ó–∞–¥–∞—á–∏: 30 | Rust Book: –ì–ª–∞–≤–∞ 4**

## –¢–µ–æ—Ä–∏—è

### 5.1 –¢—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞ Ownership

1. **–ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–µ—Ç –≤–ª–∞–¥–µ–ª—å—Ü–∞ (owner)**
2. **–£ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –û–î–ò–ù –≤–ª–∞–¥–µ–ª–µ—Ü**
3. **–ö–æ–≥–¥–∞ –≤–ª–∞–¥–µ–ª–µ—Ü –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ scope, –∑–Ω–∞—á–µ–Ω–∏–µ —É–¥–∞–ª—è–µ—Ç—Å—è**

### 5.2 Move semantics

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 –ü–ï–†–ï–ú–ï–©–Å–ù –≤ s2

// ‚ùå –æ—à–∏–±–∫–∞: s1 –±–æ–ª—å—à–µ –Ω–µ –≤–∞–ª–∏–¥–µ–Ω!
println!("{}", s1);

// ‚úÖ OK
println!("{}", s2);
```

**–ü–æ—á–µ–º—É –Ω–µ—Ç Copy?**
- `String` —Ö—Ä–∞–Ω–∏—Ç –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ
- –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –±—ã–ª–æ –±—ã –¥–æ—Ä–æ–≥–∏–º
- Move –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç double-free

**Copy types (–ø—Ä–∏–º–∏—Ç–∏–≤—ã):**
```rust
let x = 5;
let y = x; // –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è, –Ω–µ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è

// ‚úÖ –æ–±–∞ –≤–∞–ª–∏–¥–Ω—ã
println!("{} {}", x, y);
```

–¢–∏–ø—ã —Å trait `Copy`:
- –í—Å–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ: `i32`, `u64`, etc
- `bool`, `char`, `f64`
- –ö–æ—Ä—Ç–µ–∂–∏ –∏–∑ Copy —Ç–∏–ø–æ–≤: `(i32, i32)`

### 5.3 Borrowing (–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ)

**–ò–º–º—É—Ç–∞–±–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ `&T`:**
```rust
fn calculate_length(s: &String) -> usize {
    s.len()
} // s –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ scope, –Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è

let s1 = String::from("hello");
let len = calculate_length(&s1); // –ø–µ—Ä–µ–¥–∞—ë–º —Å—Å—ã–ª–∫—É
println!("{} {}", s1, len); // s1 –≤—Å—ë –µ—â—ë –≤–∞–ª–∏–¥–µ–Ω
```

**–ú—É—Ç–∞–±–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ `&mut T`:**
```rust
fn append_world(s: &mut String) {
    s.push_str(", world");
}

let mut s = String::from("hello");
append_world(&mut s);
println!("{}", s); // "hello, world"
```

### 5.4 –ü—Ä–∞–≤–∏–ª–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è

1. **–í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å:**
   - –û–¥–Ω–∞ –º—É—Ç–∞–±–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ `&mut T`
   - –ò–õ–ò –ª—é–±–æ–µ –∫–æ–ª-–≤–æ –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã—Ö `&T`

2. **–°—Å—ã–ª–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Å–µ–≥–¥–∞ –≤–∞–ª–∏–¥–Ω—ã**

```rust
let mut s = String::from("hello");

let r1 = &s;     // OK
let r2 = &s;     // OK
// let r3 = &mut s; // ‚ùå –û–®–ò–ë–ö–ê: —É–∂–µ –µ—Å—Ç—å –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã–µ

println!("{} {}", r1, r2);
// r1 –∏ r2 –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è

let r3 = &mut s; // ‚úÖ OK: –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã
r3.push_str("!");
```

### 5.5 Dangling references (–≤–∏—Å—è—á–∏–µ —Å—Å—ã–ª–∫–∏)

```rust
// ‚ùå –ù–ï –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è
fn dangle() -> &String {
    let s = String::from("hello");
    &s // s —É–¥–∞–ª–∏—Ç—Å—è, —Å—Å—ã–ª–∫–∞ —Å—Ç–∞–Ω–µ—Ç –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–π!
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ - –ø–µ—Ä–µ–¥–∞—ë–º –≤–ª–∞–¥–µ–Ω–∏–µ
fn no_dangle() -> String {
    let s = String::from("hello");
    s // –ø–µ—Ä–µ–º–µ—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—Ä—É–∂—É
}
```

### 5.6 Slice type

**String slice `&str`:**
```rust
let s = String::from("hello world");

let hello = &s[0..5];   // "hello"
let world = &s[6..11];  // "world"

// –°–æ–∫—Ä–∞—â–µ–Ω–∏—è
let slice = &s[..5];    // –æ—Ç –Ω–∞—á–∞–ª–∞
let slice = &s[6..];    // –¥–æ –∫–æ–Ω—Ü–∞
let slice = &s[..];     // –≤—Å—è —Å—Ç—Ä–æ–∫–∞
```

**Array slice `&[T]`:**
```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3]; // [2, 3]
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 5.1: Move vs Copy
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 10 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// TODO: –∏—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
fn move_semantics1() {
    let s1 = String::from("hello");
    let s2 = s1;

    // ‚ùå –æ—à–∏–±–∫–∞ - –∏—Å–ø—Ä–∞–≤—å—Ç–µ!
    println!("{}", s1);
}

fn copy_semantics() {
    let x = 5;
    let y = x;

    // ‚úÖ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ—á–µ–º—É?
    println!("{}", x);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_move() {
        move_semantics1(); // –¥–æ–ª–∂–Ω–æ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è
    }
}
```

**–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:**
1. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `s2` –≤–º–µ—Å—Ç–æ `s1`
2. –ö–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å: `let s2 = s1.clone();`
3. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É: `let s2 = &s1;`

---

### –ó–∞–¥–∞—á–∞ 5.2: –§—É–Ω–∫—Ü–∏—è —Å –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ–º
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ò—Å–ø—Ä–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, —á—Ç–æ–±—ã –æ–Ω–∞ –ø—Ä–∏–Ω–∏–º–∞–ª–∞ —Å—Å—ã–ª–∫—É

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// ‚ùå —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–±–∏—Ä–∞–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ!
fn calculate_length(s: String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(s1);

    // ‚ùå –æ—à–∏–±–∫–∞: s1 –ø–µ—Ä–µ–º–µ—â—ë–Ω!
    println!("Length of '{}' is {}.", s1, len);
}

// TODO: –∏—Å–ø—Ä–∞–≤—å—Ç–µ —Å–∏–≥–Ω–∞—Ç—É—Ä—É calculate_length
// —á—Ç–æ–±—ã –æ–Ω–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–ª–∞, –∞ –Ω–µ –∑–∞–±–∏—Ä–∞–ª–∞ –≤–ª–∞–¥–µ–Ω–∏–µ
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("Length of '{}' is {}.", s1, len);
}
```

---

### –ó–∞–¥–∞—á–∞ 5.3: –ú—É—Ç–∞–±–µ–ª—å–Ω–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn append_exclamation(s: /* TODO: —Ç–∏–ø? */) {
    // TODO: –¥–æ–±–∞–≤—å—Ç–µ "!" –∫ —Å—Ç—Ä–æ–∫–µ
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_append() {
        let mut s = String::from("hello");
        append_exclamation(/* TODO */);
        assert_eq!(s, "hello!");
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn append_exclamation(s: &mut String) {
    s.push('!');
}

#[test]
fn test_append() {
    let mut s = String::from("hello");
    append_exclamation(&mut s);
    assert_eq!(s, "hello!");
}
```

---

### –ó–∞–¥–∞—á–∞ 5.4: –ü—Ä–∞–≤–∏–ª–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–í—Ä–µ–º—è:** 25 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥ (–ù–ï –ö–û–ú–ü–ò–õ–ò–†–£–ï–¢–°–Ø!):**
```rust
fn borrowing_rules() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &mut s; // ‚ùå –æ—à–∏–±–∫–∞!

    println!("{}, {}, {}", r1, r2, r3);
}

// TODO: –∏—Å–ø—Ä–∞–≤—å—Ç–µ —Ç—Ä–∏ —Å–ø–æ—Å–æ–±–∞–º–∏:
// 1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ r3 –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ r1, r2 –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω—ã
// 2. –£–±–µ—Ä–∏—Ç–µ r3
// 3. –°–¥–µ–ª–∞–π—Ç–µ r1, r2 –º—É—Ç–∞–±–µ–ª—å–Ω—ã–º–∏
```

---

### –ó–∞–¥–∞—á–∞ 5.5: –ü–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ (slices)
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–í—Ä–µ–º—è:** 30 –º–∏–Ω—É—Ç

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –∏–∑ —Å—Ç—Ä–æ–∫–∏

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            // TODO: –≤–µ—Ä–Ω–∏—Ç–µ slice –æ—Ç 0 –¥–æ i
        }
    }

    // TODO: –µ—Å–ª–∏ –ø—Ä–æ–±–µ–ª–∞ –Ω–µ—Ç, –≤–µ—Ä–Ω–∏—Ç–µ –≤—Å—é —Å—Ç—Ä–æ–∫—É
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_first_word() {
        let s = String::from("hello world");
        assert_eq!(first_word(&s), "hello");

        let s2 = String::from("hello");
        assert_eq!(first_word(&s2), "hello");
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}
```

**–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è:**
```rust
// –ü—Ä–∏–Ω–∏–º–∞–µ–º &str –≤–º–µ—Å—Ç–æ &String - —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –æ–±–æ–∏–º–∏!
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    s
}
```

---

[–ó–∞–¥–∞—á–∏ 5.6-5.30: —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –Ω–∞ ownership, borrowing, slices...]

---

# –ú–û–î–£–õ–¨ 6: –°—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –º–µ—Ç–æ–¥—ã
**–ù–µ–¥–µ–ª–∏: 5-6 | –ó–∞–¥–∞—á–∏: 25 | Rust Book: –ì–ª–∞–≤–∞ 5**

## –¢–µ–æ—Ä–∏—è

### 6.1 –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

// –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
let user1 = User {
    email: String::from("user@example.com"),
    username: String::from("username123"),
    active: true,
    sign_in_count: 1,
};

// –î–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º
println!("{}", user1.email);

// –ú—É—Ç–∞–±–µ–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("another"),
    active: true,
    sign_in_count: 1,
};

user2.email = String::from("newemail@example.com");
```

### 6.2 Field init shorthand

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,    // –≤–º–µ—Å—Ç–æ email: email
        username, // –≤–º–µ—Å—Ç–æ username: username
        active: true,
        sign_in_count: 1,
    }
}
```

### 6.3 Struct update syntax

```rust
let user2 = User {
    email: String::from("another@example.com"),
    ..user1  // –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è –∫–æ–ø–∏—Ä—É—é—Ç—Å—è –∏–∑ user1
};

// –í–ù–ò–ú–ê–ù–ò–ï: user1.username –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ user2!
// user1.username –±–æ–ª—å—à–µ –Ω–µ –≤–∞–ª–∏–¥–µ–Ω, –Ω–æ user1.active - –≤–∞–ª–∏–¥–µ–Ω (Copy)
```

### 6.4 Tuple structs

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–æ–ª—è!
```

### 6.5 Unit-like structs

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;
```

### 6.6 –ú–µ—Ç–æ–¥—ã

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // –ú–µ—Ç–æ–¥ (–ø—Ä–∏–Ω–∏–º–∞–µ—Ç &self)
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // –ú–µ—Ç–æ–¥ —Å –º—É—Ç–∞—Ü–∏–µ–π
    fn double(&mut self) {
        self.width *= 2;
        self.height *= 2;
    }

    // –ú–µ—Ç–æ–¥, –∑–∞–±–∏—Ä–∞—é—â–∏–π ownership
    fn destroy(self) {
        // self —É–¥–∞–ª—è–µ—Ç—Å—è
    }

    // –ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä)
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    // –ï—â—ë –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
let rect = Rectangle::new(30, 50);
let area = rect.area();

let sq = Rectangle::square(10);
```

### 6.7 –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ impl –±–ª–æ–∫–∏

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

### 6.8 Debug trait

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

let rect = Rectangle { width: 30, height: 50 };
println!("{:?}", rect);    // Debug format
println!("{:#?}", rect);   // Pretty-print
dbg!(&rect);               // Debug –º–∞–∫—Ä–æ—Å
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 6.1: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ User
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// TODO: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É User —Å –ø–æ–ª—è–º–∏:
// - username: String
// - email: String
// - age: u8
// - active: bool

// TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
fn build_user(username: String, email: String, age: u8) -> User {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user() {
        let user = build_user(
            String::from("alice"),
            String::from("alice@example.com"),
            25
        );
        assert_eq!(user.username, "alice");
        assert_eq!(user.age, 25);
        assert!(user.active);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 6.2: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ Rectangle
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ area
    fn area(&self) -> u32 {
        todo!()
    }

    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä new
    fn new(width: u32, height: u32) -> Rectangle {
        todo!()
    }

    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä square
    fn square(size: u32) -> Rectangle {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_area() {
        let rect = Rectangle::new(30, 50);
        assert_eq!(rect.area(), 1500);
    }

    #[test]
    fn test_square() {
        let sq = Rectangle::square(10);
        assert_eq!(sq.area(), 100);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 6.3: –ú–µ—Ç–æ–¥ can_hold
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥, –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–π, –º–æ–∂–µ—Ç –ª–∏ –æ–¥–∏–Ω –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ–º–µ—Å—Ç–∏—Ç—å—Å—è –≤ –¥—Ä—É–≥–æ–π

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        // TODO: –≤–µ—Ä–Ω–∏—Ç–µ true –µ—Å–ª–∏ self –±–æ–ª—å—à–µ other
        // –ø–æ –æ–±–µ–∏–º dimensions
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_can_hold() {
        let rect1 = Rectangle::new(30, 50);
        let rect2 = Rectangle::new(10, 40);
        let rect3 = Rectangle::new(60, 45);

        assert!(rect1.can_hold(&rect2));
        assert!(!rect1.can_hold(&rect3));
    }
}
```

---

[–ó–∞–¥–∞—á–∏ 6.4-6.25: Point, Circle, Person, Car, etc...]

---

# –ú–û–î–£–õ–¨ 7: Enums –∏ Pattern Matching
**–ù–µ–¥–µ–ª–∏: 6-7 | –ó–∞–¥–∞—á–∏: 30 | Rust Book: –ì–ª–∞–≤–∞ 6**

## –¢–µ–æ—Ä–∏—è

### 7.1 –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ Enums

```rust
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

### 7.2 Enums —Å –¥–∞–Ω–Ω—ã–º–∏

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));

// –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö!
enum Message {
    Quit,                       // –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö
    Move { x: i32, y: i32 },    // –∞–Ω–æ–Ω–∏–º–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
    Write(String),              // String
    ChangeColor(i32, i32, i32), // —Ç—Ä–∏ i32
}
```

### 7.3 –ú–µ—Ç–æ–¥—ã –¥–ª—è Enums

```rust
impl Message {
    fn call(&self) {
        // —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è...
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

### 7.4 Option<T>

**–ù–µ—Ç null –≤ Rust!** –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ:
```rust
enum Option<T> {
    Some(T),
    None,
}

let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;

// ‚ùå –ù–ï –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è - –Ω–µ–ª—å–∑—è —Å–º–µ—à–∏–≤–∞—Ç—å T –∏ Option<T>!
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y; // –æ—à–∏–±–∫–∞!

// ‚úÖ –ù—É–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å Option
let sum = x + y.unwrap_or(0);
```

### 7.5 match Expression

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

// match –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–º!
// ‚ùå –æ—à–∏–±–∫–∞ - –Ω–µ –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ–∫—Ä—ã—Ç—ã
fn bad_match(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        // –æ—Å—Ç–∞–ª—å–Ω—ã–µ?
    }
}
```

### 7.6 Patterns —Å –¥–∞–Ω–Ω—ã–º–∏

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // ...
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

### 7.7 Matching Option<T>

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

### 7.8 Placeholder _

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (), // –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ
}
```

### 7.9 if let

```rust
let some_value = Some(3);

// –î–ª–∏–Ω–Ω—ã–π —Å–ø–æ—Å–æ–±
match some_value {
    Some(3) => println!("three"),
    _ => (),
}

// –ö–æ—Ä–æ—Ç–∫–∏–π —Å–ø–æ—Å–æ–±
if let Some(3) = some_value {
    println!("three");
}

// –° else
if let Some(3) = some_value {
    println!("three");
} else {
    println!("not three");
}
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 7.1: Enum Traffic Light
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåü
**–í—Ä–µ–º—è:** 15 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// TODO: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ enum TrafficLight —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏:
// Red, Yellow, Green

// TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
fn duration(light: TrafficLight) -> u8 {
    // Red: 60, Yellow: 5, Green: 45
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_duration() {
        assert_eq!(duration(TrafficLight::Red), 60);
        assert_eq!(duration(TrafficLight::Yellow), 5);
        assert_eq!(duration(TrafficLight::Green), 45);
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 7.2: Option - safe division
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåü
**–í—Ä–µ–º—è:** 20 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// TODO: –≤–µ—Ä–Ω–∏—Ç–µ Some(—Ä–µ–∑—É–ª—å—Ç–∞—Ç) –∏–ª–∏ None –ø—Ä–∏ –¥–µ–ª–µ–Ω–∏–∏ –Ω–∞ 0
fn safe_divide(dividend: i32, divisor: i32) -> Option<i32> {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_safe_divide() {
        assert_eq!(safe_divide(10, 2), Some(5));
        assert_eq!(safe_divide(10, 3), Some(3)); // —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ
        assert_eq!(safe_divide(10, 0), None);
    }
}
```

**–†–µ—à–µ–Ω–∏–µ:**
```rust
fn safe_divide(dividend: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None
    } else {
        Some(dividend / divisor)
    }
}
```

---

### –ó–∞–¥–∞—á–∞ 7.3: Enum Message
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–í—Ä–µ–º—è:** 30 –º–∏–Ω—É—Ç

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
// TODO: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ enum Message —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏:
// - Quit
// - Move { x: i32, y: i32 }
// - Write(String)
// - ChangeColor(u8, u8, u8)

impl Message {
    fn call(&self) {
        // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ match –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–∂–¥–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞
        // –∏ –≤—ã–≤–µ–¥–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message() {
        let messages = vec![
            Message::Quit,
            Message::Move { x: 10, y: 20 },
            Message::Write(String::from("hello")),
            Message::ChangeColor(255, 0, 0),
        ];

        for msg in messages {
            msg.call();
        }
    }
}
```

---

[–ó–∞–¥–∞—á–∏ 7.4-7.30: Result, —Å–ª–æ–∂–Ω—ã–µ pattern matching, etc...]

---

# –ú–û–î–£–õ–¨ 8: –ö–æ–ª–ª–µ–∫—Ü–∏–∏
**–ù–µ–¥–µ–ª–∏: 7-8 | –ó–∞–¥–∞—á–∏: 35 | Rust Book: –ì–ª–∞–≤–∞ 8**

## –¢–µ–æ—Ä–∏—è

### 8.1 Vector

```rust
// –°–æ–∑–¥–∞–Ω–∏–µ
let v: Vec<i32> = Vec::new();
let v = vec![1, 2, 3];

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ
let mut v = Vec::new();
v.push(5);
v.push(6);

// –ß—Ç–µ–Ω–∏–µ
let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);

// –ò—Ç–µ—Ä–∞—Ü–∏—è
for i in &v {
    println!("{}", i);
}

// –ú—É—Ç–∞–±–µ–ª—å–Ω–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
for i in &mut v {
    *i += 50;
}

// Vec —Å enum –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

### 8.2 String

```rust
// –°–æ–∑–¥–∞–Ω–∏–µ
let mut s = String::new();
let s = "initial contents".to_string();
let s = String::from("initial contents");

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ
let mut s = String::from("foo");
s.push_str("bar");
s.push('!');

// –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1 –ø–µ—Ä–µ–º–µ—â—ë–Ω!

// format! –º–∞–∫—Ä–æ—Å (–Ω–µ –∑–∞–±–∏—Ä–∞–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ)
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{}-{}-{}", s1, s2, s3);

// –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –ù–ï —Ä–∞–±–æ—Ç–∞–µ—Ç!
// ‚ùå let h = s[0];

// –ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ —Å–∏–º–≤–æ–ª–∞–º
for c in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".chars() {
    println!("{}", c);
}

// –ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ –±–∞–π—Ç–∞–º
for b in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".bytes() {
    println!("{}", b);
}
```

### 8.3 HashMap

```rust
use std::collections::HashMap;

// –°–æ–∑–¥–∞–Ω–∏–µ
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

// –°–æ–∑–¥–∞–Ω–∏–µ –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤
let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
let scores: HashMap<_, _> = teams.iter()
    .zip(initial_scores.iter())
    .collect();

// –ß—Ç–µ–Ω–∏–µ
let team_name = String::from("Blue");
let score = scores.get(&team_name); // Option<&V>

// –ò—Ç–µ—Ä–∞—Ü–∏—è
for (key, value) in &scores {
    println!("{}: {}", key, value);
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ
scores.insert(String::from("Blue"), 25); // –ø–µ—Ä–µ–∑–∞–ø–∏—Å—å

// –í—Å—Ç–∞–≤–∫–∞ –µ—Å–ª–∏ –Ω–µ—Ç
scores.entry(String::from("Blue")).or_insert(50);

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ä–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
let text = "hello world wonderful world";
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 8.1: –°—Ä–µ–¥–Ω–µ–µ, –º–µ–¥–∏–∞–Ω–∞, –º–æ–¥–∞
**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** üåüüåüüåü
**–í—Ä–µ–º—è:** 45 –º–∏–Ω—É—Ç

**–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:**
–î–ª—è —Å–ø–∏—Å–∫–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –≤—ã—á–∏—Å–ª–∏—Ç–µ:
1. –°—Ä–µ–¥–Ω–µ–µ (mean)
2. –ú–µ–¥–∏–∞–Ω—É (median) - —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
3. –ú–æ–¥—É (mode) - –∑–Ω–∞—á–µ–Ω–∏–µ, –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è —á–∞—â–µ –≤—Å–µ–≥–æ

**–°—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥:**
```rust
use std::collections::HashMap;

fn mean(numbers: &[i32]) -> f64 {
    // TODO: –≤—ã—á–∏—Å–ª–∏—Ç–µ —Å—Ä–µ–¥–Ω–µ–µ
    todo!()
}

fn median(numbers: &mut [i32]) -> f64 {
    // TODO: –æ—Ç—Å–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –∏ –Ω–∞–π–¥–∏—Ç–µ —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    // –ü–æ–¥—Å–∫–∞–∑–∫–∞: numbers.sort()
    // –î–ª—è —á—ë—Ç–Ω–æ–≥–æ –∫–æ–ª-–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ - —Å—Ä–µ–¥–Ω–µ–µ –¥–≤—É—Ö —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö
    todo!()
}

fn mode(numbers: &[i32]) -> i32 {
    // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ HashMap –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞ —á–∞—Å—Ç–æ—Ç—ã
    // –í–µ—Ä–Ω–∏—Ç–µ —á–∏—Å–ª–æ —Å –Ω–∞–∏–±–æ–ª—å—à–µ–π —á–∞—Å—Ç–æ—Ç–æ–π
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mean() {
        assert_eq!(mean(&[1, 2, 3, 4, 5]), 3.0);
        assert_eq!(mean(&[2, 4, 6]), 4.0);
    }

    #[test]
    fn test_median() {
        assert_eq!(median(&mut [1, 2, 3, 4, 5]), 3.0);
        assert_eq!(median(&mut [1, 2, 3, 4]), 2.5);
    }

    #[test]
    fn test_mode() {
        assert_eq!(mode(&[1, 2, 2, 3, 3, 3, 4]), 3);
        assert_eq!(mode(&[5, 5, 5, 1, 2]), 5);
    }
}
```

---

[–ó–∞–¥–∞—á–∏ 8.2-8.35: —Ä–∞–±–æ—Ç–∞ —Å Vec, String, HashMap...]

---

# –ú–û–î–£–õ–¨ 9: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ (Result)
**–ù–µ–¥–µ–ª–∏: 8-9 | –ó–∞–¥–∞—á–∏: 20 | Rust Book: –ì–ª–∞–≤–∞ 9**

## –¢–µ–æ—Ä–∏—è

### 9.1 Result<T, E>

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

use std::fs::File;

let f = File::open("hello.txt");

let f = match f {
    Ok(file) => file,
    Err(error) => panic!("Problem opening: {:?}", error),
};
```

### 9.2 –û–ø–µ—Ä–∞—Ç–æ—Ä ?

```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?; // –µ—Å–ª–∏ Err - –≤–µ—Ä–Ω—ë—Ç –µ–≥–æ
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

// –ï—â—ë –∫–æ—Ä–æ—á–µ —Å chain
fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
```

### 9.3 –ö–∞—Å—Ç–æ–º–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫

```rust
use std::fmt;

#[derive(Debug)]
enum MyError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    CustomError(String),
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MyError::IoError(e) => write!(f, "IO error: {}", e),
            MyError::ParseError(e) => write!(f, "Parse error: {}", e),
            MyError::CustomError(msg) => write!(f, "Error: {}", msg),
        }
    }
}

impl std::error::Error for MyError {}
```

---

[–ó–∞–¥–∞—á–∏ 9.1-9.20...]

---

# –ú–û–î–£–õ–¨ 10: Generics –∏ Traits
**–ù–µ–¥–µ–ª–∏: 9-10 | –ó–∞–¥–∞—á–∏: 25 | Rust Book: –ì–ª–∞–≤–∞ 10**

## –¢–µ–æ—Ä–∏—è

### 10.1 Generic —Ñ—É–Ω–∫—Ü–∏–∏

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
```

### 10.2 Generic —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
}

// –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã
struct Point<T, U> {
    x: T,
    y: U,
}
```

### 10.3 Traits

```rust
pub trait Summary {
    fn summarize(&self) -> String;

    // Default implementation
    fn default_summary(&self) -> String {
        String::from("(Read more...)")
    }
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```

### 10.4 Trait bounds

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}

// –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ bounds
pub fn notify<T: Summary + Display>(item: &T) {
    // ...
}

// where clause
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // ...
}
```

---

[–ó–∞–¥–∞—á–∏ 10.1-10.25...]

---

# –ú–û–î–£–õ–¨ 11-16 –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç—Å—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ...

# –ú–û–î–£–õ–¨ 16: Backend —Å Axum
**–ù–µ–¥–µ–ª–∏: 15-16 | –ó–∞–¥–∞—á–∏: 50 | –§–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–µ–∫—Ç**

## –¢–µ–æ—Ä–∏—è

### 16.1 –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Axum

```toml
[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

### 16.2 Hello World API

```rust
use axum::{
    routing::get,
    Router,
};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(handler));

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    axum::serve(listener, app).await.unwrap();
}

async fn handler() -> &'static str {
    "Hello, Axum!"
}
```

### 16.3 JSON API

```rust
use axum::{Json, response::IntoResponse};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
}

async fn create_user(
    Json(payload): Json<User>,
) -> impl IntoResponse {
    Json(payload)
}

let app = Router::new()
    .route("/users", post(create_user));
```

---

## –§–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–µ–∫—Ç: Blog API

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:**
- CRUD –¥–ª—è –ø–æ—Å—Ç–æ–≤
- –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è JWT
- PostgreSQL
- –¢–µ—Å—Ç—ã

[–î–µ—Ç–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏...]

---

# üéì –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–í—ã –ø—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π –∫—É—Ä—Å –æ—Ç –æ—Å–Ω–æ–≤ –¥–æ backend —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏!

**–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:**
1. –ò–∑—É—á–∏—Ç–µ async patterns –≥–ª—É–±–∂–µ
2. –ü–æ–ø—Ä–∞–∫—Ç–∏–∫—É–π—Ç–µ—Å—å —Å real-world –ø—Ä–æ–µ–∫—Ç–∞–º–∏
3. –ò–∑—É—á–∏—Ç–µ production deployment

**–†–µ—Å—É—Ä—Å—ã:**
- The Rust Book: https://doc.rust-lang.org/book/
- Rustlings: https://rustlings.cool/
- Rust by Example: https://doc.rust-lang.org/rust-by-example/

**–£–¥–∞—á–∏ –≤ –∏–∑—É—á–µ–Ω–∏–∏ Rust! ü¶Ä**
